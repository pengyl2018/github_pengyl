一.消息队列在高并发系统设计中起到的作用：
1.削峰填谷（如秒杀系统）
削峰填谷是消息队列最主要的作用，但是会造成请求处理的延迟。
2.异步处理
异步处理是提升系统性能的神器，但是你需要分清同步流程和异步流程的边界，同时消息存在着丢失的风险，我们需要考虑如何确保消息一定到达。
3.解耦合
解耦合可以提升你的整体系统的鲁棒性。

二.消息丢失的场景
1.发送过程中丢失
消息队列一般部署在服务器上，当网络出现问题时，生产的消息就会丢失。
解决方法：重传
缺点：可能造成消息重复发送。
2.消息队列中丢失消息
消息队列如kafka为了消息能持久化，一般会将消息存在磁盘上，为了提升写入性能，一般会批量地写入，也就意味着一段时间内消息是存在page cache中的，待cache中的内容积累到一定数量时再异步地刷一次盘，当还未刷盘时机器宕机，重启后此时cache中的内容丢失。
解决方法：
（1）对丢失消息丢失零容忍，那么以集群的方式部署kafka服务，通过部署多个副本备份数据来保证数据不丢失，当所有的isr follower都收到消息才返回成功。
（2）对丢失消息有一定的容忍度，那么建议不用部署集群，就算部署了集群，也建议只发送给一个isr follower就可以返回成功。一般的业务对消息是有容忍度的，比如红包没有发，后续可以补发。
3.消费过程中消息会丢失
例如kafka，消费消息可分为接收消息、处理消息、更新消费进度三个步骤，这里接收消息和处理消息都可能发生异常，此时直接更新消费进度，会导致该条消息永远都不会被处理了。
解决方法：一定要等到接收和处理消息成功后再更新消费进度
缺点：会造成重复消费。例如接收和处理消息后正好宕机，此时还没有更新消费的进度，重启后该消息会被重复消费。

三.如何保证消息只被消费一次
方法：在生产消费过程中增加消息幂等性的保证
1.生产过程中消息的幂等性：虽然在生产端可能会重复生产相同的消息，但是在队列中只会存在同一份。具体做法如下：赋予生产者唯一的ID，赋予每一条消息唯一的ID，组成一个映射<生产者ID：最后一条消息的ID>，每次来一条消息（带着对应的生产者ID），通过生产者ID找到最后一条消息的ID，若该ID和当前消息的ID一致，则认为该条消息是重复的。
2.消费过程中的幂等性：
（1）通用层：可以在消息被生产的时候使用发号器给它生成一个全局唯一的消息 ID，消息被处理之后把这个 ID 存储在数据库中，在处理下一条消息之前先从数据库里面查询这个全局 ID 是否被消费过，如果被消费过就放弃消费。（严格来说需要用到事务，处理消息和存储的操作要放在一个事务中）
（2）业务层：给每个人的账号数据中增加一个版本号的字段，在生产消息时先查询这个账户的版本号，并且将版本号连同消息一起发送给消息队列。消费端在拿到消息和版本号后，在执行更新账户金额 SQL 的时候带上版本号，类似于执行：update user set amount = amount + 20, version=version+1 where userId=1 and version=1;当我们在更新数据时给数据加了乐观锁，这样在消费第一条消息时，version 值为 1，SQL 可以执行成功，并且同时把 version 值改为了 2；在执行第二条相同的消息时，由于 version 值不再是 1，所以这条 SQL 不能执行成功，也就保证了消息的幂等性。